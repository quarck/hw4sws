{sample: true}
# Chapter Two - Combination Circuits 

## Pure Functions of Hardware World 

First class of digital devices and circuits we are going to examine is called *combination circuits*. 

Combination circuit is a circuit number of input signals, number of output signals, and the main characteristic of the combination circuit is that its outputs are only depend on the current values of input signals and nothing else. 

From this perspective combination circuits are similar to pure functions of functional programming world. 

## Definition by The Table 

Combination Circuit could be considered as a black-box with N inputs and M outputs. Let's denote by the letter *F* the function of the black box that defines relationship between inputs and outputs. 

Such function *F* can be fully defined by the table that lists all possible combinations of the input signals and provides expected output signals for a given set of inputs. An example of such table is given on the table 2.1 below. Here we have three input signals: *A*, *B*, and *C*, and two output signals - *O1* and *O2*, in the table we use 0 for logical LOW and 1 for logical HIGH signal values. 

| A | B | C | O1 | O2 | 
|---|---|---| ---| ---|
| 0 | 0 | 0 | 0  | 0  |
| 0 | 0 | 1 | 1  | 0  |
| 0 | 1 | 0 | 1  | 0  |
| 0 | 1 | 1 | 0  | 1  |
| 1 | 0 | 0 | 1  | 0  |
| 1 | 0 | 1 | 0  | 1  |
| 1 | 1 | 0 | 0  | 1  |
| 1 | 1 | 1 | 1  | 0  |

{width: "80%"}![table 2.1 - example function defined by the table](ch2_tab_log_func.svg)

Another possible way of defining function *F* is by providing a logical expression(s) for the output value(s). 

In fact, any function provided in table form can be re-written as a logical expression as well, lets see how this can be done. 
Let's take our function defined by the table 2.1 and focus on output *O1* first. This output takes logical HIGH or true in logical terms when: 
* A=0, B=0, C=1 (2nd row)
* A=0, B=1, C=0 (3rd row)
* A=1, B=0, C=0 (5th row)
* A=1, B=1, C=1 (8th row)

All the other rows produce logical LOW or false (or '0').
 
So if were writing a program, let say in python, we would write the following expression obviously for the O1 value: 
```python
O1 = 1 \
	if ((A==0 and B==0 and C==1)
		or (A==0 and B==1 and C==0)
		or (A==1 and B==0 and C==0) 
		or (A==1 and B==1 and C==1)) \
	else 0
``` 

and since A, B and C are themselves logical values, as well as the output, we can simply write: 

```python
O1 = (not A and not B and C) \
	or (not A and B and not C) \
	or (A and not B and not C)
	or (A and B and C)
``` 

The same can be written using mathematical notation: 

```$
O_{1} = \bar{A} \bar{B} C +
	\bar{A} B \bar{C} +
	A \bar{B} \bar{C} + 
	A B C 
``` 

Alternatively we can write the expression based on rows producing 0: 

```python
O1 = 0 \
	if ((A==0 and B==0 and C==0) 
		or (A==0 and B==1 and C==1) 
		or (A==1 and B==0 and C==1)  
		or (A==1 and B==1 and C==0)) \
	else 1
``` 

Again, simplifying based on the fact that A, B, C are boolean values: 

```python
O1 = not ((not A and not B and not C) \
		or (not A and B and C) \
		or (A and not B and C)  \
		or (A and B and not C))
``` 

Let's get rid of 'not' in front by replacing to: 

```python
O1 = not (not A and not B and not C) \
	 and not (not A and B and C) \
	 and not (A and not B and C)  \
	 and not (A and B and not C)
``` 

And then further moving 'not' into individual braces: 

```python
O1 = (A or B or C) \
	 and (A or not B or not C) \
	 and (not A or B or not C)  \
	 and (not A or not B or C)
``` 

Finally, let's write the latter using math notation: 

{caption: "equation 2.2"}
```$
O_{1} = 
(A + B + C) 
(A + \bar{B} + \bar{C})
(\bar{A} + B + \bar{C})  
(\bar{A} + \bar{B} + C)

``` 

Both 2.1 and 2.2 are equal logical expressions that equally define the output O1. 





In fact we could have skipped all the python-ish part, and went straight into writing this expression, the rule is very simple: we take only rows that produce logical high, for each row we write an expression part *AND*-ing all the inputs, if matching input has '0' in this row - it is taken inverse ('not'), if it has '1' - we take it directly, and then we *OR* all these individual parts into the final expression.


If we do the same for O2 we would fully define functionality of this combination circuit using expression form. 


But the expression we've got for O1 is far from optimal and we can simplify it a bit by the way of applying boolean algebra expression transformation rules: 

```$
O_{1} = \bar{A} \bar{B} C +
	\bar{A} B \bar{C} +
	A \bar{B} \bar{C} + 
	A B C 
``` 

```$
O_{1} = \bar{A} (\bar{B} C + B \bar{C}) + A ( \bar{B} \bar{C} + B C )
``` 

It is not hard to see that `\bar{B} C + B \bar{C}`$ is in fact XOR, in math symbols written as `B \oplus C`$. 
And similarly `\bar{B} \bar{C} + B C`$ is in fact XNOR, in math notation written as `\overline{B \oplus C}`$.

Thus, replacing these sub-expressions into XOR/XNOR symbols: 

```$
O_{1} = \bar{A} (B \oplus C) + A (\overline{B \oplus C})
``` 

Very similarly, the latter is on its own a XOR between `A`$ and `B \oplus C`$, thus we can finally write: 

```$
O_{1} = A \oplus B \oplus C
``` 

This is certainly much nicer and concise expression. 


## Examples of Combination Circuits 

### MUX 

### 4-1 MUX 

### Demux 