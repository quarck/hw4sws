{sample: true}
# Chapter Two - Combination Circuits 

## Pure Functions of Hardware World 

First class of digital devices and circuits we are going to examine is called *combination circuits*. 

Combination circuit is a circuit number of input signals, number of output signals, and the main characteristic of the combination circuit is that its outputs are only depend on the current values of input signals and nothing else. 

From this perspective combination circuits are similar to pure functions of functional programming world. 

## Definition by The Table 

Combination Circuit could be considered as a black-box with N inputs and M outputs. Let's denote by the letter *F* the function of the black box that defines relationship between inputs and outputs. 

Such function *F* can be fully defined by the table that lists all possible combinations of the input signals and provides expected output signals for a given set of inputs. An example of such table is given on the table 2.1 below. Here we have three input signals: *A*, *B*, and *C*, and two output signals - *X* and *Y*, in the table we use 0 for logical LOW and 1 for logical HIGH signal values. 

{width: "80%"}![Table 2.1 - example function defined by the table](ch2_tab_log_func.svg)

Another possible way of defining function *F* is by providing a logical expression(s) for the output value(s). 

In fact, any function provided in table form can be re-written as a logical expression as well, lets see how this can be done. 
Let's take our function defined by the table 2.1 and focus on output *X* first. 
This output takes logical HIGH or true in logical terms when: 
* A=0, B=0, C=1 (2nd row)
* A=0, B=1, C=0 (3rd row)
* A=1, B=0, C=0 (5th row)
* A=1, B=1, C=1 (8th row)

All the other rows produce logical LOW or false (or '0').
 
So if were writing a C-like program, we would write something like:
```C
X = ( (A==0 && B==0 && C==1) || 
	  (A==0 && B==1 && C==0) || 
	  (A==1 && B==0 && C==0) || 
	  (A==1 && B==1 && C==1) )
	? 1 : 0;
``` 

or better, since A, B and C are logical values, we can simply write: 

```C
X = (!A && !B && C) || (!A && B && !C) ||
	(A && !B && !C) || (A && B && C);
``` 

The same can be written using mathematical notation: 

`O_{1} = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} + A B C`$ 			~(2.1)~

Alternatively we can write the expression based on rows producing 0: 

```C
X = !( (!A && !B && !C) || (!A && B && C) || 
	   (A && !B && C) || (A && B && !C) )
``` 

If we move logical NOT one level in into the braces: 

```C
X = !(!A && !B && !C) && !(!A && B && C) && 
	   !(A && !B && C) && !(A && B && !C)
``` 

The finally, latter can be written as: 

```C
X = (A || B || C) && (A || !B || !C) && 
	   (!A || B || !C) && (!A || !B || C)
``` 

Finally, let's write the latter using math notation: 

{caption: "(2.2)"}
```$
O_{1} = 
(A + B + C) 
(A + \bar{B} + \bar{C})
(\bar{A} + B + \bar{C})  
(\bar{A} + \bar{B} + C)
``` 

Both 2.1 and 2.2 are equivalent logical expressions that define the output O1. 

The type of expression we've produced in 2.1 has called *disjunctive normal form* of the function and each of individual -or-ed components (`\bar{A} \bar{B} C`$, etc) is called a *minterm*.
 Similarly the 2.2 type is called *conjunctive normal form* and each individual -and-ed component (`(A + B + C)`$, etc) is called a *maxterm*. 

If we look closely at expressoins 2.1 and 2.2 it is not hard to see how we can directly derive those from the table form of the O1. 

For *disjunctive normal form*, we select all the rows producing value '1', each such row forms individual *minterm*. If there is '0' for against particular input value, it goes with the *not* into minterm, otherwise it goes as it is. Thus, we create as many minterms as there are '1's on the output and finally *OR* all the minterms  to produce the resulting expression. 

For *conjunctive normal form* we select all the rows producing value '0', each row forms individual *maxterm*. If there is '1' against particular input value, it goes with the *not* into a maxterm, otherwise it goes as it is. Again, we create as many maxterms as there are '0's in the output, and finally *AND* all the maxterms to produce the resulting expression. 

Depending on the particular function it might be easier to use either *disjunctive* or *conjunctive* normal forms: for example if function produces only a few '0's and all the outputs in the table are '1's, the *conjunctive* form would result in much shorter expression. 

Lets practice and use *disjunctive normal form* to produce the expression for *Y* directly. 

Enumerating all the rows producing '1' for Y we get: 
* A=0, B=1, C=1, so the minterm is `\bar{A} B C`$
* A=1, B=0, C=1, so the minterm is `A \bar{B} C`$
* A=1, B=1, C=0, so the minterm is `A B \bar{C}`$
* A=1, B=1, C=1, so the minterm is `A B C`$

Now combining all the minterms: 

{caption: "(2.3)"}
```$
Y = 
\bar{A} B C + 
A \bar{B} C +
A B \bar{C} +
A B C
```

As reader might have started suspecting, none of expressions 2.1, 2.2, 2.3 is optimal. Let's take expression 2.1 and try using the rules of boolean algebra to simplify it:

The original expression: 

```$
X = \bar{A} \bar{B} C +
	\bar{A} B \bar{C} +
	A \bar{B} \bar{C} + 
	A B C 
``` 

grouping similar terms together: 

```$
X = \bar{A} \bar{B} C +
	\bar{A} B \bar{C} +
	A \bar{B} \bar{C} + 
	A B C 
``` 

```$
X = \bar{A} (\bar{B} C + B \bar{C}) + A ( \bar{B} \bar{C} + B C )
``` 

It is not hard to see that `\bar{B} C + B \bar{C}`$ is in fact XOR, in math symbols written as `B \oplus C`$. 
And similarly `\bar{B} \bar{C} + B C`$ is in fact XNOR, in math notation written as `\overline{B \oplus C}`$.

Thus, replacing these sub-expressions into XOR/XNOR symbols: 

```$
X = \bar{A} (B \oplus C) + A (\overline{B \oplus C})
``` 

Very similarly, the latter is on its own a XOR between `A`$ and `B \oplus C`$, thus we can finally write: 

{caption: "(2.4)"}
```$
X = A \oplus B \oplus C
``` 

Lets do the same for Y (eq. 2.3): 

The original expression: 

```$
Y =  \bar{A} B C +  A \bar{B} C + A B \bar{C} + A B C
```
Grouping: 

```$
Y =  (\bar{A} + A) B C +  A (\bar{B} C + B \bar{C}) 
```
The `\bar{A} + A`$ term is always true, so can be eliminated, and ``$ is again XOR function, thus: 

{caption: "(2.5)"}
```$
Y =  B C +  A (B \oplus C) 
```

With the equations 2.4 and 2.5 we have fully defined by the expression the output of the function defined by the table 2.1. 


## Karnaugh Map


## Example Implementation 



## Examples of Combination Circuits 

### MUX 

### 4-1 MUX 

### Demux 