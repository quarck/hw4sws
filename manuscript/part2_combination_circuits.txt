{sample: true}
# Chapter Two - Combination Circuits 

## Pure Functions of Hardware World 

First class of digital devices and circuits we are going to examine is called *combination circuits*. 

Combination circuit is a circuit number of input signals, number of output signals, and the main characteristic of the combination circuit is that its outputs are only depend on the current values of input signals and nothing else. 

From this perspective combination circuits are similar to pure functions of functional programming world. 

## Ways To Define Combination Circuit

Combination Circuit could be considered as a black-box with N inputs and M outputs. Let's denote by the letter *F* the function of the black box that defines relationship between inputs and outputs. 

Such function *F* can be fully defined by the table that lists all possible combinations of the input signals and provides expected output signals for a given set of inputs. An example of such table is given on the table 2.1 below. Here we have three input signals: *A*, *B*, and *C*, and two output signals - *X* and *Y*, in the table we use 0 for logical LOW and 1 for logical HIGH signal values. 

{width: "80%"}![Table 2.1 - example function defined by the table](ch2_tab_log_func.svg)

Another possible way of defining function *F* is by providing a logical expression(s) for the output value(s). 

In fact, any function provided in table form can be re-written as a logical expression as well, lets see how this can be done. 
Let's take our function defined by the table 2.1 and focus on output *X* first. If we were to write the C-style code that produces value for *X*, we would have written something like: 

```C
X = ( (A==0 && B==0 && C==1) || 
      (A==0 && B==1 && C==0) || 
      (A==1 && B==0 && C==0) || 
      (A==1 && B==1 && C==1) )
    ? 1 : 0;
```

In a condition we test to see if combination of inputs matches one of the rows producing *X=1* (rows 2, 3, 5, 8), and if so - we output 1, otherwise we output 0. 

But since *A*, *B*, *C* and output are boolean / logical values, we can simply write: 

```C
X = (!A && !B && C) || (!A && B && !C) ||
    (A && !B && !C) || (A && B && C);
``` 

We've got a boolean logic expression for output *X*, the same can be written in math notation: 

```$
X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} + A B C
``` 

Alternatively we can write the condition that tests for rows producing '0' and make our expression output '1' if we don't match any of these rows: 

```C
X = !(A==0 && B==0 && C==0) && !(A==0 && B==1 && C==1) && 
    !(A==1 && B==0 && C==1) && !(A==1 && B==1 && C==0)
``` 

The latter can simplified to: 

```C
X = (A || B || C) && (A || !B || !C) && 
    (!A || B || !C) && (!A || !B || C)
``` 

Or, equally, using math notation: 

```$
X = (A + B + C) (A + \bar{B} + \bar{C}) (\bar{A} + B + \bar{C})  (\bar{A} + \bar{B} + C)
```

Both final expressions are equivalent and define the same output *X*.

The first type of expression `X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} + A B C`$  is called *disjunctive normal form* of the function and each of individual -or-ed components (`\bar{A} \bar{B} C`$, etc) is called a *minterm*.

The second expression `X = (A + B + C) (A + \bar{B} + \bar{C}) (\bar{A} + B + \bar{C})  (\bar{A} + \bar{B} + C)`$) is called *conjunctive normal form* of the function, and each individual -and-ed component (`(A + B + C)`$, etc) is called a *maxterm*. 

If we look closely at these expressions again, it is not hard to see how we can directly derive those from the table form of the *X*. 

For *disjunctive normal form*, we select all the rows producing value '1', each such row forms individual *minterm*. If there is '0' for against particular input value, it goes with the *not* into minterm, otherwise it goes as it is. Thus, we create as many minterms as there are '1's on the output and finally *OR* all the minterms  to produce the resulting expression. 

For *conjunctive normal form* we select all the rows producing value '0', each row forms individual *maxterm*. If there is '1' against particular input value, it goes with the *not* into a maxterm, otherwise it goes as it is. Again, we create as many maxterms as there are '0's in the output, and finally *AND* all the maxterms to produce the resulting expression. 

Depending on the particular function it might be easier to use either *disjunctive* or *conjunctive* normal forms: for example if function produces only a few '0's and all the outputs in the table are '1's, the *conjunctive* form would result in much shorter expression. 

Lets practice and use *disjunctive normal form* to produce the expression for *Y* directly. We select the rows that make output value of Y to be equal 1, and build a minterm out of each of these, see figure 2.1. 

{width: "80%"}![Figure 2.1 - Example DNF construct](ch2_dnf_example.svg)
 
Now we combining all the minterms into the final expression: 

```$
Y = \bar{A} B C +  A \bar{B} C + A B \bar{C} + A B C
```

As reader might have started suspecting, none of expressions we've got so far is optimal. Let's take the first one and try optimizing by applying the rules of boolean algebra to convert the expression into something smaller: 

The original expression: 

```$
X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} + A B C
```

grouping similar terms together: 

```$
X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} +  A B C
```

```$
X = \bar{A} (\bar{B} C + B \bar{C}) + A ( \bar{B} \bar{C} + B C )
```

It is not hard to see that `\bar{B} C + B \bar{C}`$ is in fact *XOR*, in math symbols written as `B \oplus C`$. 
And similarly `\bar{B} \bar{C} + B C`$ is in fact *XNOR*, in math notation written as `\overline{B \oplus C}`$.

Thus, replacing these sub-expressions into XOR/XNOR symbols: 

```$
X = \bar{A} (B \oplus C) + A (\overline{B \oplus C})
```

Very similarly, the latter is on its own a *XOR* between `A`$ and `B \oplus C`$, thus we can finally write: 

```$
X = A \oplus B \oplus C
```


Lets do the same for *Y*: 

The original expression: 

```$
Y =  \bar{A} B C +  A \bar{B} C + A B \bar{C} + A B C
```

Grouping: 

```$
Y =  (\bar{A} B + A \bar{B}) C + A B ( \bar{C} + C )
```

The `\bar{C} + C`$ term is always true, so can be eliminated, and `\bar{A} B + A \bar{B}`$ is again a *XOR* function, thus: 

```$
Y =  (A \oplus B) C + A B
```

This way, we have fully defined by the expression the output of the function defined by the table 2.1. 


## Implementation Using Logic Gates 

Let us once again focus our attention on the combination circuit defined by the table 2.1, for which we've produced simplified logical expressions for outputs *X* and *Y*, and see how we can implement in a physical circuit using logic gates. 

Once again, expressions we've got for *X* and *Y* are: 

```$
\begin{align*}
X &= A \oplus B \oplus C  \\
Y &= (A \oplus B) C + A B
\end{align*}
```

This very first circuit - let us build it slowly step by step, just to make it easier to read. We would be operating with elementary base consisting of logic gates with only two inputs.

First step is a circuit for sub-expression `A \oplus B`$, it is just a simple single *XOR* gate, figure 2.2: 

{width: "70%"}![Figure 2.2 - A xor B](ch2_a_xor_b.svg)

Then we add a second *XOR* gate to produce `X = A \oplus B \oplus C`$, we just chain another *XOR* gate, figure 2.3: 

{width: "70%"}![Figure 2.3 - A xor B xor C](ch2_a_xor_b_xor_c.svg)

And that's the gate network for output *X* already. Now we implement network for *Y*. The `A \oplus B`$ term is also required for *Y* so we can re-use it and go directly into implementing `(A \oplus B) C`$, figure 2.4: 

{width: "70%"}![Figure 2.4 - A xor B xor C | (A xor B) and C](ch2_a_xor_b_xor_c___a_xor_b_and_c.svg)

Now we add a parallel `A B`$ term, figure 2.5:  

{width: "70%"}![Figure 2.5 - A xor B xor C | (A xor B) and C] | A and B](ch2_a_xor_b_xor_c___a_xor_b_and_c__a_and_b.svg)

Finally we combine `(A \oplus B) C`$ with `A B`$ to produce the full circuit for output *Y*, figure 2.6: 

{width: "70%"}![Figure 2.6 - Logic gate implementation of table 2.1](ch2_anon_adder.svg)

And that is the gate network that would produce the exact output as was defined by the table 2.1. 
The resulting implementation takes only 5 gates, that is way less than if we were to implement the original *DNF* or *CNF* based form. 


## One Bit Full Adder 

The combination circuit defined by the table 2.1 is in fact an important base component, it has its own name - **full adder**. To get its canonical form we only need to rename input *C* into *C~in~* - for 'carry in', *X* into *S* - for 'Sum', and *Y* into *C~out~ * - for 'carry out'. See table 2.2 and figure 2.7.

{width: "80%"}![Table 2.2 - example function defined by the table](ch2_tab_adder_func.svg)

{width: "70%"}![Figure 2.7 - Full Adder](ch2_adder.svg)

Full adder computes arithmetic sum of three individual bits - *A*, *B*, *C~in~* and produces two-bit output where most significant bit is *C~out~ * and least significant bit is *S*. The *C~in~* input is necessary for chaining multiple full adders into wider (N-bit) adders - we would see how very soon. 

In the circuit diagrams, full adder is usually displayed as a rectangle with inputs on the left and outputs on the right, each input / output has a corresponding label inside the rectangle, see figure 2.8.

{width: "65%"}![Figure 2.8 - Full Adder](ch2_adder_symbol.svg)

Component similar to a full adder, but  without *C~in~* input is called *half adder*: it has inputs *A* and *B*, and produces the same *S* and *C~out~*. By combining two half adders with *OR* gate, we could build a full adder, as shown on the figure 2.9. 

{width: "70%"}![Figure 2.9 - two half adders](ch2_half_adders.svg)

As an optional exercise, try building the table that would define functionality of the half-adder, then produce the logical expressions for the outputs and the circuit implementation, then finally compare the resulting circuit for the half adder vs full adder implementation. (See the appendix B for the half-adder circuit implementation).


## Karnaugh Maps

In the previous section we did a laborious manual work in order to simplify functions presented in their disjunctive normal forms into something smaller. 
Luckily there is simpler method exists. Method was introduced by Maurice Karnaugh and named after him - *Karnaugh Map*. The method utilizes our natural ability to recognize graphical patterns in the tables, avoiding working with the boolean algebra expressions. It works well for up to functions of up to four arguments, and with some tricks can be used for functions of five arguments.

Fluency with Karnaugh maps is not really necessary for comprehension of the further chapters of this book, but some familiarity is necessary to understand some important aspects, so we would take some break from circuits and would spend some time with Karnaugh maps in this chapter now. 

The formal description of this method can be a bit complicated (and boring), it is much easier to demonstrate the method by the example. Let's start with the function of three arguments *A*, *B* and *C*, defined by the table 2.3 below, output of the function is denoted as *Y*. 

{width: "80%"}![Table 2.3](ch2_tab_three_args_karnaugh_maps.svg)

For three-input function with start with the empty two-dimensional table formatted as on the figure 2.10. 

{width: "65%"}![Figure 2.10 - Empty three variable Karnaugh map](ch2_empty_three_variable_kmap.svg)

Vertical index of this table would match variable *A*, and horizontal index would consist of pair of values *B,C* - e.g. indexes are *00*, *01*, *11*, *10*, where first digit in each pair corresponds to the value of *B* and second corresponds to the value of *C*. Reader might have noticed an irregularity in that index sequence: indexes are ordered in such a way that every adjacent indexes are only different by a single bit. Such sequence has a special name - *gray code*, it has many different uses in the digital circuits design. 
Back to to our two-dimensional table, we fill it with the values from the original table 2.3, by placing corresponding 0 / 1 values in the matching cells, as on the figure 2.11: 

{width: "65%"}![Figure 2.11 - Karnaugh map example](ch2_example_three_variable_kmap.svg)

On the next step we should include each '1' from the map into one or multiple groups (but at least one). Groups are formed from adjacent '1's that should form a rectangle with each side being a power of two  - 1x1 is also allowed for group consisting of one element. The map should be considered as wrapping around the edges. There should be no '0's inside the group. Our goal is to find the least amount of largest size groups that cover all '1's. Each group would produce a single term in the resulting expression, and the larger group is - smaller would be the term. 
For our example function we would get two groups as shown on figure 2.12. 

{width: "65%"}![Figure 2.12 - Karnaugh map example](ch2_example_three_variable_kmap_with_groups.svg)

First group consisting of cells for *A,B,C=0,0,0* and *A,B,C=0,1,0*. If we were to write disjunctive normal form, these two cells would result in terms `\bar{A} \bar{B} \bar{C}`$ and `\bar{A} B \bar{C}`$, it is clear that *and* operation between these two terms can be simplified to just `\bar{A} \bar{C}`$, and that's the idea how Karnaugh map works. But instead of looking at the logical expressions we only need to check - which of the indexes is present in all possible combinations in the group, and the corresponding argument is eliminated from the resulting term. In this case it is B - it is present as '0' in the leftmost cell, and as '1' in the rightmost, while all the other indexes are equal (*A=0, C=0*). 

Second group is formed from cells for *A,B,C=1,0,1* and *A,B,C=1,1,1*. And again, B is present in both values '0' (left) and '1' (right) here, thus it is eliminated, the resulting term is `A C`$. 

Combining two terms (one per group) we could write the result: 

```$
Y = \bar{A} \bar{C} + A C
```

The latter one can be written as a *XNOR* between *A*, *C* as we already know: 

```$
Y = \overline{A \oplus C}
```

Karnaugh map would no help us in recognizing *XOR*/*XNOR* gates where they could be used to simplify the expression. This is not a huge concern since, as we know, *XOR*/*XNOR* gates are themselves composite gates consisting of multiple simpler gates (*NAND/NOR* or other types). Thus, substitution to *XOR*/*XNOR* only serves as a convenience for human beings working with the boolean expressions, and not changing the actual 'under the hood' implementation. 


### Karnaugh maps - more examples 

Let us take a few more examples of other functions to see various possible groups that could be made in each case. In order to save space and reader's time, we would skip the table form and would go directly into Karnaugh map of each function. So let's go. 

{width: "65%"}![Figure 2.13 - Karnaugh map example](ch2_example_vert_single_group.svg)

Figure 2.13 above shows an example of a single vertical group, for that group index *A* is present in both '0' and '1' values, and index *BC* has value '01', thus *A* is eliminated, and result would consist of a single term: 

```$
Y = \bar{B} C
```

{width: "65%"}![Figure 2.14 - Karnaugh map example](ch2_example_vert_horiz_overlap_groups.svg)

Figure 2.14 demonstrates 'inconvenient' allocation of triangle-shaped form of '1's. They could be grouped into two groups as shown on the picture. Vertical one has index *A* present as both '0' and '1', producing term `\bar{B} C`$ and horizontal group having *B* present in both cells, while *A=1*, and *C=1*, thus term for the second group is `A C`$. Combining together: 

```$
Y = \bar{B} C + A C
```

Latter expression requires at least two *AND* operations and one *OR*, we could manually convert it into:

```$
Y = (\bar{B} + A ) C
```

This would require one *AND* and one *OR*. (But both cases would still need another *NOT* to invert *B*). 

Our next example, figure 2.15.

{width: "65%"}![Figure 2.15 - Karnaugh map example](ch2_example_vert_horiz_horiz_overlap_groups.svg)

On the figure 2.15 we have a horizontal span of three '1's, but unfortunately they can't be converted into a single group as its length is not a power of two. So we end up with three groups as shown on the picture. First two terms are the same as for the previous function, and the last term would eliminate *C*', keeping A (=1) and B(=1), thus third term is `A B`$, and resulting expression is: 

```$
Y = \bar{B} C + A C + A B
```

We keep moving on and adding '1's into the bottom row, figure 2.16: 

{width: "65%"}![Figure 2.16 - Karnaugh map example](ch2_example_vert_long_horiz_groups.svg)

On the figure 2.16 we can finally combine the whole bottom row into one big group, and this time the whole pair *BC* can be eliminated as this pair is present in all its combinations: 00, 01, 11, 10. Resulting term for the second group is just `A`$. The first group is the same as the first group for the previous expression, so result is: 

```$
Y = A + \bar{B} C
```

One step further, another '1' slipped into the table, figure 2.17: 

{width: "65%"}![Figure 2.17 - Karnaugh map example](ch2_example_vertbig_long_horiz_groups.svg)

On the figure 2.17 we have two groups again, one bulky 2x2 group and one horizontal consisting of the whole bottom row. The bulky one eliminates *A* (it has both '0' and '1') and B (again, present as both '0' and '1'), thus the term would be just `C`$, and the other term is the same as before - `A`$. Result is simple: 

```$
Y = A + C 
```

Continuing the trend, we add another '1', figure 2.18: 

{width: "65%"}![Figure 2.18 - Karnaugh map example](ch2_example_all_bug_single_zero.svg)

Same as with some previous functions, on the figure 2.18 we could get multiple different group arrangements, but our goal is to maximize group sizes while reducing total number of groups. We cant get less than three groups here, so we span each group to the max size possible, resulting groups produce terms `A`$, `B`$ and `C`$, and the full expression is: 

```$
Y = A + B + C
```

Finally, pushing it to the limits, we fill the whole table with '1's, figure 2.19. 

{width: "65%"}![Figure 2.19 - Karnaugh map example](ch2_example_all_ones.svg)

In this table everything is just one large group, all the arguments are eliminated, result is just constant: 

```$
Y = 1
```

### Karnaugh maps - functions of four arguments 
 
Karnaugh map of a function of four arguments is similar to three argument one, but instead of single-argument vertical index we now have composite indexes on both axis, both using gray code. So let say our inputs are A, B, C, D. Vertical index would take pair of A,B and horizontal index takes C,D. 
Let's take another example function, given by the table 2.4. 

For that function we build map as follows: 


** __TODO__**

## Ripple Carry Adder 

By chaining multiple single-bit full adders we could create a circuit that produces addition of two numbers of any number of binary digits, like the 4-bit adder producing 5-bit result shown on figure 2.**XX**. We would get back to a one-bit adder later in this chapter.

{width: "90%"}![Figure 2.XX - 4-bit adder](ch2_4_bit_adder.svg)

**tbd**

## Carry Lookahead Adder 

**tbd**

## MUX 

### 4-1 MUX 

## Demux 

## Something else?? 
