{sample: true}
# Chapter Two - Combination Circuits 

## Pure Functions of Hardware World 

First class of digital devices and circuits we are going to examine is called *combination circuits*. 

Combination circuit is a circuit number of input signals, number of output signals, and the main characteristic of the combination circuit is that its outputs are only depend on the current values of input signals and nothing else. 

From this perspective combination circuits are similar to pure functions of functional programming world. 

## Ways To Define Combination Circuit

Combination Circuit could be considered as a black-box with N inputs and M outputs. Let's denote by the letter *F* the function of the black box that defines relationship between inputs and outputs. 

Such function *F* can be fully defined by the table that lists all possible combinations of the input signals and provides expected output signals for a given set of inputs. An example of such table is given on the table 2.1 below. Here we have three input signals: *A*, *B*, and *C*, and two output signals - *X* and *Y*, in the table we use 0 for logical LOW and 1 for logical HIGH signal values. 

{width: "80%"}![Table 2.1 - example function defined by the table](ch2_tab_log_func.svg)

Another possible way of defining function *F* is by providing a logical expression(s) for the output value(s). 

In fact, any function provided in table form can be re-written as a logical expression as well, lets see how this can be done. 
Let's take our function defined by the table 2.1 and focus on output *X* first. If we were to write the C-style code that produces value for *X*, we would have written something like: 

```C
X = ( (A==0 && B==0 && C==1) || 
      (A==0 && B==1 && C==0) || 
      (A==1 && B==0 && C==0) || 
      (A==1 && B==1 && C==1) )
    ? 1 : 0;
```

In a condition we test to see if combination of inputs matches one of the rows producing X=1 (rows 2, 3, 5, 8), and if so - we output 1, otherwise we output 0. 

But since A, B, C and output are boolean / logical values, we can simply write: 

```C
X = (!A && !B && C) || (!A && B && !C) ||
    (A && !B && !C) || (A && B && C);
``` 

We've got a boolean logic expression for output X, the same can be written in math notation: 

```$
X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} + A B C
``` 

Alternatively we can write the condition that tests for rows producing '0' and make our expression output '1' if we don't match any of these rows: 

```C
X = !(A==0 && B==0 && C==0) && !(A==0 && B==1 && C==1) && 
    !(A==1 && B==0 && C==1) && !(A==1 && B==1 && C==0)
``` 

The latter can simplified to: 

```C
X = (A || B || C) && (A || !B || !C) && 
    (!A || B || !C) && (!A || !B || C)
``` 

Or, equally, using math notation: 

```$
X = (A + B + C) (A + \bar{B} + \bar{C}) (\bar{A} + B + \bar{C})  (\bar{A} + \bar{B} + C)
```

Both final expressions are equivalent and define the same output X.

The first type of expression `X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} + A B C`$  is called *disjunctive normal form* of the function and each of individual -or-ed components (`\bar{A} \bar{B} C`$, etc) is called a *minterm*.

The second expression `X = (A + B + C) (A + \bar{B} + \bar{C}) (\bar{A} + B + \bar{C})  (\bar{A} + \bar{B} + C)`$) is called *conjunctive normal form* of the function, and each individual -and-ed component (`(A + B + C)`$, etc) is called a *maxterm*. 

If we look closely at these expressions again, it is not hard to see how we can directly derive those from the table form of the X. 

For *disjunctive normal form*, we select all the rows producing value '1', each such row forms individual *minterm*. If there is '0' for against particular input value, it goes with the *not* into minterm, otherwise it goes as it is. Thus, we create as many minterms as there are '1's on the output and finally *OR* all the minterms  to produce the resulting expression. 

For *conjunctive normal form* we select all the rows producing value '0', each row forms individual *maxterm*. If there is '1' against particular input value, it goes with the *not* into a maxterm, otherwise it goes as it is. Again, we create as many maxterms as there are '0's in the output, and finally *AND* all the maxterms to produce the resulting expression. 

Depending on the particular function it might be easier to use either *disjunctive* or *conjunctive* normal forms: for example if function produces only a few '0's and all the outputs in the table are '1's, the *conjunctive* form would result in much shorter expression. 

Lets practice and use *disjunctive normal form* to produce the expression for *Y* directly. We select the rows that make output value of Y to be equal 1, and build a minterm out of each of these, see figure 2.1. 

{width: "80%"}![Figure 2.1 - Example DNF construct](ch2_dnf_example.svg)
 
Now we combining all the minterms into the final expression: 

```$
Y = \bar{A} B C +  A \bar{B} C + A B \bar{C} + A B C
```

As reader might have started suspecting, none of expressions we've got so far is optimal. Let's take the first one and try optimizing by applying the rules of boolean algebra to convert the expression into something smaller: 

The original expression: 

```$
X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} + A B C
```

grouping similar terms together: 

```$
X = \bar{A} \bar{B} C + \bar{A} B \bar{C} + A \bar{B} \bar{C} +  A B C
```

```$
X = \bar{A} (\bar{B} C + B \bar{C}) + A ( \bar{B} \bar{C} + B C )
```

It is not hard to see that `\bar{B} C + B \bar{C}`$ is in fact XOR, in math symbols written as `B \oplus C`$. 
And similarly `\bar{B} \bar{C} + B C`$ is in fact XNOR, in math notation written as `\overline{B \oplus C}`$.

Thus, replacing these sub-expressions into XOR/XNOR symbols: 

```$
X = \bar{A} (B \oplus C) + A (\overline{B \oplus C})
```

Very similarly, the latter is on its own a XOR between `A`$ and `B \oplus C`$, thus we can finally write: 

```$
X = A \oplus B \oplus C
```


Lets do the same for Y: 

The original expression: 

```$
Y =  \bar{A} B C +  A \bar{B} C + A B \bar{C} + A B C
```

Grouping: 

```$
Y =  (\bar{A} B + A \bar{B}) C + A B ( \bar{C} + C )
```

The `\bar{C} + C`$ term is always true, so can be eliminated, and `\bar{A} B + A \bar{B}`$ is again a XOR function, thus: 

```$
Y =  (A \oplus B) C + A B
```

This way, we have fully defined by the expression the output of the function defined by the table 2.1. 


## Implementation Using Logic Gates 

Let us once again focus our attention on the combination circuit defined by the table 2.1, for which we've produced simplified logical expressions for outputs X and Y, and see how we can implement in a physical circuit using logic gates. 

Once again, expressions we've got for X and Y are: 

```$
\begin{align*}
X &= A \oplus B \oplus C  \\
Y &= (A \oplus B) C + A B
\end{align*}
```

This very first circuit - let us build it slowly step by step, just to make it easier to read. We would be operating with elementary base consisting of logic gates with only two inputs.

First step is a circuit for sub-expression `A \oplus B`$, it is just a simple single XOR gate, figure 2.2: 

{width: "70%"}![Figure 2.2 - A xor B](ch2_a_xor_b.svg)

Then we add a second XOR gate to produce `X = A \oplus B \oplus C`$, we just chain another XOR gate, figure 2.3: 

{width: "70%"}![Figure 2.3 - A xor B xor C](ch2_a_xor_b_xor_c.svg)

And that's the gate network for output X already. Now we implement network for Y. The `A \oplus B`$ term is also required for Y, so we can re-use it and go directly into implementing `(A \oplus B) C`$, figure 2.4: 

{width: "70%"}![Figure 2.4 - A xor B xor C | (A xor B) and C](ch2_a_xor_b_xor_c___a_xor_b_and_c.svg)

Now we add a parallel `A B`$ term, figure 2.5:  

{width: "70%"}![Figure 2.5 - A xor B xor C | (A xor B) and C] | A and B](ch2_a_xor_b_xor_c___a_xor_b_and_c__a_and_b.svg)

Finally we combine `(A \oplus B) C`$ with `A B`$ to produce the full circuit for output Y, figure 2.6: 

{width: "70%"}![Figure 2.6 - Logic gate implementation of table 2.1](ch2_anon_adder.svg)

And that is the gate network that would produce the exact output as was defined by the table 2.1. 


## One Bit Full Adder 




## Karnaugh Maps


## Example Implementation 



## Examples of Combination Circuits 

### MUX 

### 4-1 MUX 

### Demux 